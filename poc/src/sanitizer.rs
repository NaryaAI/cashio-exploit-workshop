use std::borrow::BorrowMut;

use anchor_lang::prelude::Pubkey;
use converter::SaberSwap;
use solana_program::{
    program_pack::Pack,
    sysvar::Sysvar,
    clock::Clock
};
use spl_token::state::{Mint};
use stable_swap_client::state::{
    SwapInfo,
};
use sunburn::{client::LocalClientSync};

pub struct Sanitizer {
    pub bank: BankInfo,
}

pub struct CollateralInfo {
    pub wallet: Pubkey,
    pub swap_info: Pubkey,    
}

pub struct BankInfo {
    pub crate_mint: Pubkey,
    pub collaterals: Vec<CollateralInfo>
} 

impl BankInfo {
    fn check(&self, env: &mut sunburn::Environment<LocalClientSync>) -> Result<(), anyhow::Error> {
        let crate_mint_account = env.get_account(self.crate_mint)?;
        let crate_mint = Mint::unpack(&crate_mint_account.data)?;
        let cash_value: u64 = crate_mint.supply;

        let mut collateral_value: u64 = 0;
        for col in self.collaterals.iter() {
            let wallet_account = env.get_account(col.wallet)?;
            let wallet = spl_token::state::Account::unpack(&wallet_account.data)?;
 
            let swap_info_account = env.get_account(col.swap_info)?;
            let swap_info = SwapInfo::unpack(&swap_info_account.data)?;
            let pool_mint_account = env.get_account(swap_info.pool_mint)?;
            let pool_mint = Mint::unpack(&pool_mint_account.data)?;
            let token_a_account = env.get_account(swap_info.token_a.reserves)?;
            let token_a = spl_token::state::Account::unpack(&token_a_account.data)?;
            let token_b_account = env.get_account(swap_info.token_b.reserves)?;
            let token_b = spl_token::state::Account::unpack(&token_b_account.data)?;

            let saber_swap = SaberSwap {
                initial_amp_factor: swap_info.initial_amp_factor,
                target_amp_factor: swap_info.target_amp_factor,
                current_ts: swap_info.start_ramp_ts,
                start_ramp_ts: swap_info.start_ramp_ts,
                stop_ramp_ts: swap_info.stop_ramp_ts,
                lp_mint_supply: pool_mint.supply,
                token_a_reserve: token_a.amount,
                token_b_reserve: token_b.amount, 
            };

            collateral_value += saber_swap.calculate_virtual_price_of_pool_tokens(wallet.amount).unwrap();
        } 

        println!("{} {}", collateral_value, cash_value);

        assert!(collateral_value >= cash_value, "Under collateralization");
        Ok(())
    }
}

impl Sanitizer {
    pub fn check(&self, env: &mut sunburn::Environment<LocalClientSync>) -> Result<(), anyhow::Error> {
        Ok(self.bank.check(env)?)
    }
}