use anchor_lang::{prelude::*, system_program, InstructionData};
use arrow_sunny::{Arrow, ArrowMiner};
use cashio_poc::{AccountConfig, LocalEnv, LocalEnvBuilder};
use solana_program::{instruction::Instruction, native_token::sol_to_lamports, pubkey::Pubkey};
use solana_program_test::tokio;
use solana_sdk::{signature::Keypair, signer::Signer};

type Result<T, E> = std::result::Result<T, E>;

struct FakeArrow {
    _dummy: Pubkey,
    arrow_addr: Keypair,
    arrow_data: Vec<u8>,
}

fn create_fake_arrow(token_mint: Pubkey) -> FakeArrow {
    let dummy = Keypair::new();
    let arrow_addr = Keypair::new();

    let vendor_miner = ArrowMiner {
        mint: token_mint,
        rewarder: dummy.pubkey(),
        quarry: dummy.pubkey(),
        miner: dummy.pubkey(),
        miner_vault: dummy.pubkey(),
        rewards_mint: dummy.pubkey(),
        mint_wrapper: dummy.pubkey(),
        claim_fee_token_account: dummy.pubkey(),
        vault_staked_token_account: dummy.pubkey(),
        vault_rewards_token_account: dummy.pubkey(),
        sunny_pool_rewards_fee_account: dummy.pubkey(),
    };

    let internal_miner = ArrowMiner {
        mint: dummy.pubkey(),
        rewarder: dummy.pubkey(),
        quarry: dummy.pubkey(),
        miner: dummy.pubkey(),
        miner_vault: dummy.pubkey(),
        rewards_mint: dummy.pubkey(),
        mint_wrapper: dummy.pubkey(),
        claim_fee_token_account: dummy.pubkey(),
        vault_staked_token_account: dummy.pubkey(),
        vault_rewards_token_account: dummy.pubkey(),
        sunny_pool_rewards_fee_account: dummy.pubkey(),
    };

    let arrow = Arrow {
        mint: token_mint,
        bump: 0,
        beneficiary: dummy.pubkey(),
        pool: dummy.pubkey(),
        vault: dummy.pubkey(),
        vendor_miner: vendor_miner,
        internal_miner: internal_miner,
    };

    let mut arrow_data = Vec::new();
    arrow.try_serialize(&mut arrow_data).unwrap();

    FakeArrow {
        _dummy: dummy.pubkey(),
        arrow_addr,
        arrow_data,
    }
}

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // prepare mock environment
    let bankman_data = std::fs::read("cashio/target/deploy/bankman.so")?;
    let brrr_data = std::fs::read("cashio/target/deploy/brrr.so")?;
    let crate_token_data = std::fs::read("dep-programs/crate-token-0.6.0.so")?;
    let arrow_sunny_data = std::fs::read("dep-programs/arrow_sunny-0.3.1.so")?;

    let saber_authority = Keypair::new();
    let cashio_authority = Keypair::new();

    let saber_lp_mint = Keypair::new();
    let cashio_mint = Keypair::new();

    let fake_arrow = create_fake_arrow(saber_lp_mint.pubkey());

    let hacker = Keypair::new();

    let mut env = LocalEnvBuilder::new()
        .add_program(bankman::ID, bankman_data)
        .add_program(brrr::ID, brrr_data)
        .add_program(crate_token::ID, crate_token_data)
        .add_program(arrow_sunny::ID, arrow_sunny_data)
        .add_account(
            fake_arrow.arrow_addr.pubkey(),
            AccountConfig {
                data: fake_arrow.arrow_data,
                owner: arrow_sunny::ID,
                ..Default::default()
            },
        )
        .add_account(
            cashio_authority.pubkey(),
            AccountConfig {
                lamports: Some(sol_to_lamports(1_000_000.0)),
                ..Default::default()
            },
        )
        .add_account(
            hacker.pubkey(),
            AccountConfig {
                lamports: Some(sol_to_lamports(1.0)),
                ..Default::default()
            },
        )
        .build()
        .await;

    // 1. Prepare Saber LP token
    // Note: decimals were arbitrarily chosen
    env.create_token_mint(&saber_lp_mint, saber_authority.pubkey(), None, 8)
        .await?;

    // 2. Prepare Cash token
    let (cashio_crate_token, cashio_crate_token_bump) = Pubkey::find_program_address(
        &[b"CrateToken".as_ref(), &cashio_mint.pubkey().to_bytes()],
        &crate_token::ID,
    );

    let (bank, bank_bump) = Pubkey::find_program_address(
        &[b"Bank".as_ref(), &cashio_crate_token.to_bytes()],
        &bankman::ID,
    );

    env.create_token_mint(
        &cashio_mint,
        cashio_crate_token,
        Some(cashio_crate_token),
        bankman::CASH_DECIMALS,
    )
    .await?;

    // 3. Initialize a new bank
    env.run_instruction(
        Instruction {
            program_id: bankman::ID,
            accounts: bankman::accounts::NewBank {
                bank,
                crate_mint: cashio_mint.pubkey(),
                crate_token: cashio_crate_token,
                brrr_issue_authority: brrr::ISSUE_AUTHORITY_ADDRESS,
                burn_withdraw_authority: brrr::WITHDRAW_AUTHORITY_ADDRESS,
                payer: cashio_authority.pubkey(),
                admin: cashio_authority.pubkey(),
                system_program: system_program::ID,
                crate_token_program: crate_token::ID,
            }
            .to_account_metas(None),
            data: bankman::instruction::NewBank {
                _bank_bump: bank_bump,
                crate_bump: cashio_crate_token_bump,
            }
            .data(),
        },
        &[&cashio_authority],
    )
    .await?;

    // 4. Add the saber LP token as a collateral
    let (saber_lp_collateral, saber_lp_collateral_bump) = Pubkey::find_program_address(
        &[
            b"Collateral".as_ref(),
            &bank.to_bytes(),
            &saber_lp_mint.pubkey().to_bytes(),
        ],
        &bankman::ID,
    );

    env.run_instruction(
        Instruction {
            program_id: bankman::ID,
            accounts: bankman::accounts::AuthorizeCollateral {
                bank,
                collateral: saber_lp_collateral,
                mint: saber_lp_mint.pubkey(),
                curator: cashio_authority.pubkey(),
                payer: cashio_authority.pubkey(),
                system_program: system_program::ID,
            }
            .to_account_metas(None),
            data: bankman::instruction::AuthorizeCollateral {
                _bump: saber_lp_collateral_bump,
            }
            .data(),
        },
        &[&cashio_authority],
    )
    .await?;

    /* TODO: Remaining steps
    mint some Saber LP tokens and Cash
    victim print cash with their Saber LP token (to fill the bank)
    */

    println!("Successfully initialized!");

    // execute PoC
    let hacker_info = HackerInfo {};
    execute_poc(&mut env, hacker_info).await?;

    // TODO: validate PoC

    Ok(())
}

struct HackerInfo {}

async fn execute_poc(env: &mut LocalEnv, hacker_info: HackerInfo) -> Result<(), anyhow::Error> {
    // Write your exploit here
    Ok(())
}
