use solana_program::{
    bpf_loader, instruction::Instruction, loader_instruction, system_instruction,
};
use solana_program_test::{BanksClient, BanksClientError, ProgramTest, ProgramTestContext};
use solana_sdk::{message::Message, signature::Keypair, signer::Signer, transaction::Transaction};

pub struct ProgramTestWrapper {
    context: ProgramTestContext,
}

type Result<T> = std::result::Result<T, BanksClientError>;

/// Many of these are adapted from Solana PoC framework by Neodyme
/// TODO: set a proper code license
impl ProgramTestWrapper {
    pub async fn new(program_test: ProgramTest) -> Self {
        let context = program_test.start_with_context().await;
        ProgramTestWrapper { context }
    }

    pub fn client(&mut self) -> &mut BanksClient {
        &mut self.context.banks_client
    }

    pub fn payer(&self) -> &Keypair {
        &self.context.payer
    }

    async fn instructions_to_tx_impl(
        &mut self,
        instructions: &[Instruction],
        signers: &[&Keypair],
    ) -> Result<Transaction> {
        let recent_blockhash = self.client().get_latest_blockhash().await?;
        let payer = self.payer();

        let mut signers_vec = vec![payer];
        signers_vec.extend_from_slice(signers);

        let message = Message::new(instructions, Some(&self.payer().pubkey()));
        Ok(Transaction::new(&signers_vec, message, recent_blockhash))
    }

    pub async fn instructions_to_tx(
        &mut self,
        instructions: &[Instruction],
        signers: &[&Keypair],
    ) -> Result<Transaction> {
        self.instructions_to_tx_impl(instructions, signers).await
    }

    pub async fn instruction_to_tx(
        &mut self,
        instruction: Instruction,
        signers: &[&Keypair],
    ) -> Result<Transaction> {
        self.instructions_to_tx_impl(&[instruction], signers).await
    }

    pub async fn run_transaction(&mut self, transaction: Transaction) -> Result<()> {
        self.client().process_transaction(transaction).await
    }

    pub async fn run_instructions(
        &mut self,
        instructions: &[Instruction],
        signers: &[&Keypair],
    ) -> Result<()> {
        let transaction = self.instructions_to_tx(instructions, signers).await?;
        self.run_transaction(transaction).await?;

        Ok(())
    }

    pub async fn run_instruction(
        &mut self,
        instruction: Instruction,
        signers: &[&Keypair],
    ) -> Result<()> {
        let transaction = self.instruction_to_tx(instruction, signers).await?;
        self.run_transaction(transaction).await?;

        Ok(())
    }

    /// Create an executable account using a given keypair.
    pub async fn deploy_program(&mut self, account: &Keypair, data: &[u8]) -> Result<()> {
        self.create_account_with_data(account, data).await?;
        self.run_instruction(
            loader_instruction::finalize(&account.pubkey(), &bpf_loader::id()),
            &[account],
        )
        .await?;

        Ok(())
    }

    /// Executes a transaction creating and filling the given account with the given data.
    /// The account is required to be empty and will be owned by bpf_loader afterwards.
    pub async fn create_account_with_data(&mut self, account: &Keypair, data: &[u8]) -> Result<()> {
        let exemption_amount = self.client().get_rent().await?.minimum_balance(data.len());
        self.run_instruction(
            system_instruction::create_account(
                &self.payer().pubkey(),
                &account.pubkey(),
                exemption_amount,
                data.len() as u64,
                &bpf_loader::id(),
            ),
            &[account],
        )
        .await?;

        let mut offset = 0usize;
        for chunk in data.chunks(900) {
            self.run_instruction(
                loader_instruction::write(
                    &account.pubkey(),
                    &bpf_loader::id(),
                    offset as u32,
                    chunk.to_vec(),
                ),
                &[account],
            )
            .await?;
            offset += chunk.len();
        }

        Ok(())
    }
}
